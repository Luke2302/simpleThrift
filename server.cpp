#include <iostream>
#include <string>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h> //Check func
#include <thrift/transport/TSocket.h> //Needed?
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>

#include "gen-cpp/helloService.h" 
#include "gen-cpp/hello_types.h" 

//Create Handler Class

//helloServiceIf is a virtual class generated by the 
//thrift compilier. You must create a subclass 
//which in this case is called helloServiceHandler

class helloServiceHandler : virtual public helloServiceIf {
    public:
    
    //Class constructor 
    helloServiceHandler() {
        printf("onstructor has been called \n");
    }
    

    //Hello Func
    //Strange syntax. Within .thrift declared as string hello_func().
    //return string and takes no args -> pure virtual function has no overrider error

    void hello_func(std::string& myReturn){
        printf("hello_func has been remotely called, a message will be returned\n");
        std::string message = "This is hello_func returning a string message\n";
        myReturn = message;
    }

    //Add Func

    int32_t add(int32_t num1, int32_t num2){
        printf("add function has been called remotely\n");
        printf("%i and %i will be added\n", num1, num2);
        int32_t sum = num1 +num2;
        printf("Sum is: %i\n", sum);
    }

}; //Semi colon at the end of a class

int main() {

    int port = 1234;
    
    //New handler

    std::shared_ptr<helloServiceHandler> handler(new helloServiceHandler());

    //New processor (handler)

    std::shared_ptr<apache::thrift::TProcessor> processor(new helloServiceProcessor(handler));
    
    //New Server Socket (port)

    std::shared_ptr<apache::thrift::transport::TServerSocket> serverSocket(new apache::thrift::transport::TServerSocket(port));

    //Server transport

    std::shared_ptr<apache::thrift::server::TServerTransport> serverTransport(serverSocket);
    
    //Transport Buffered Factory

    std::shared_ptr<apache::thrift::transport::TTransportFactory> transportFactory(new apache::thrift::transport::TBufferedTransportFactory);

    //Binary Protocol Factory

    std::shared_ptr<apache::thrift::protocol::TProtocolFactory> protocolFactory(new apache::thrift::protocol::TBinaryProtocolFactory);

    //Instantiate (correct?) a server
    //Why do I need the factories for my code?
    //Why do I need a single serverTransport but not single protocol?
    apache::thrift::server::TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

    //Serve server
    server.serve();

    return 0;
}